# カプセル化の方針（変更に強いシステムにするための SRP とそれを作りやすくするためのアーキテクチャ）

## このページのまとめ（編集中）

### オブジェクト指向とレイヤードアーキテクチャ入門

### オブジェクト指向の 3 要素

- **カプセル化（クラス）**⇐ コイツ
- **継承**
- **ポリモーフィズム**

この中でも特に大事なのは **カプセル化＝責務を分けて整理すること** です。  
ただし、現実世界の役割をそのままクラスにするのは危険です。

---

### よくある勘違い

#### 勘違い ：現実のモノとクラスは 1 対 1 で対応する（オブジェクト指向は現実の写しではない）

- 「車というモノがあるから Car クラスを作る」
- 「ホール担当がいるから HallStaff クラスを作る」

➡ これは誤解です。

クラスの粒度は「目的によって変わる」もので、現実の役割をそのまま持ち込むと変更に弱い設計になります。

---

### 正しい考え方：責務を分ける（レイヤードアーキテクチャ）

現実の仕事をそのまま 1 つのクラスに押し込むと、責務がごちゃ混ぜになります。  
そこで「レイヤードアーキテクチャ」という枠組みを使い、**役割を整理**します。

#### レイヤーの役割

- **プレゼンテーション 層**：お客様とのやり取り（Controller）
- **アプリケーション層**：ユースケースの流れを制御（Service）
- **ドメイン層**：ビジネスルールを定義（Entity, ValueObject）⇐ 今回は使わないし、ここの Entity はまた使うやつとは別物
- **インフラ層**：データ保存や外部連携（Repository, DB アクセス）

---

### ユースケースで考える

#### ユースケース 1：お客様が注文する

1. **プレゼンテーション 層（ホール担当）**

   - 「カレーを 1 つ」と注文を受ける
   - API で言えば `POST /orders`

2. **アプリケーション層（ホール担当＋キッチン担当）**

   - 注文受付の流れを管理（注文登録 → 在庫確認 → 厨房依頼）

3. **ドメイン層（キッチン担当）**

   - 「カレーを作るにはルーと米が必要」
   - 「在庫不足ならエラー」

4. **インフラ層（キッチン担当）**
   - 在庫を確認し、注文データを保存

---

### なぜこの粒度でレイヤーを分けるのか？

目的は「変更に強くすること」です。  
そのための考え方が **SRP（単一責務の原則）** です。

- **SRP**：クラスは「1 つの理由でしか変更されない」ように設計する
- 責務を混ぜると、どの変更でも同じクラスを直す必要があり、保守性が下がる

#### レイヤーごとの変更理由

- UI 層 → 画面仕様や API 仕様の変更
- アプリケーション層 → 業務フローの変更
- ドメイン層 → ビジネスルールの変更
- インフラ層 → DB や外部サービスの変更

➡ それぞれの変更理由が異なるため、責務を分けてクラスを配置することが重要。

---

### レイヤードアーキテクチャの位置づけ

- **レイヤードアーキテクチャは責務分離のテンプレート**
- 実際のクラス分割は「ユースケース＝目的」を基準に、SRP を守る粒度で行う
- 言い換えると：
  - **ユースケースに基づいた責務の分割**
  - ＋ **レイヤードアーキテクチャで整理**

---

### 学習の第一歩

- 処理はしかるべきレイヤーに置く
- 「どこに書いてあるか」を予測できる力を養う

➡ これができれば、WebAPI 開発でも大規模システムでも「変更に強い設計」が理解しやすくなります。

---

## ユースケースやドメインとは何か？

- ユースケースとは、**「ユーザーがシステムを使って達成したい、単一で具体的なゴール」**を記述したものです。例えば、EC サイトの「オンラインで商品を注文する」というユースケースは、ユーザーの最終的なゴールそのものを表します。これは「決済する」のような単なる手続きとは異なります。

- ドメインとは、業務領域そのものを指します。EC サイトであれば「注文」「顧客」「商品」といった概念がドメインです。ドメイン層は、これらの概念が持つ純粋な業務ルールをカプセル化します。

---

## オブジェクト指向の単一責任の原則（SRP）：飲食店を例に考える

「オブジェクト指向は現実世界の写し」という言葉は、しばしば誤解を招きます。正確には、**「オブジェクト指向は、現実世界（や業務）の概念から、変更しやすいようにそれぞれの『責任』を明確に抽象化し、独立した部品としてモデル化する手法」**です。

現実の飲食店では、効率的な運営のために既に役割分担が行われています。しかし、**実務の都合上、一つの役割が複数の「責任」を兼ねることも少なくありません。**例として、お客様と直接対話するホール担当（ウェイター）は、形式的なチェックだけでなく、一部の業務ルールに基づく判断も行うことがあります。

システム設計においては、このような現実の兼任状態が、なぜ「変更に強くないシステム」につながるのかを理解し、**「単一責任の原則（SRP）」に基づいて、それぞれの「責任」を独立した部品として分解すること**が極めて重要になります。

### 現実の飲食店：ホール、キッチン、店長の役割分担と、システム設計での SRP による分解

一般的な飲食店では、以下のような役割分担がされています。

1.  **ホール担当:** お客様の案内、注文受付、料理の提供、会計。**状況によっては「ランチは 14 時までです」と伝えたり、「会員様は 10%割引になります」と案内する**など、一部の業務ルールに基づく判断や案内も行います。
2.  **キッチン担当:** ホールから受け取った注文の調理、食材の管理。
3.  **店長:** 店舗全体の運営管理、メニュー開発、スタッフの教育、売上管理など。

これらの現実の役割分担において、ホール担当が「形式のチェック」と「一部の業務ルールチェック」を兼任している状態を、システム設計の観点で SRP を適用し、それぞれの「責任」を独立した部品（クラス）として設計することの意義を見ていきましょう。

**なぜ現実の兼任が、システムでは「変更に強くない」のか？**

現実では効率的でも、**”システム”**でホール担当（ウェイター/Controller）が「形式チェック」と「ランチタイムの制約」や「会員割引の適用」といった**業務ルールチェック**を兼任していると、以下のような問題が発生しやすくなります。※以下はあくまでシステムが変更に弱くなってしまうという話で、現実では変更に強いかどうかよりも人件費だとか高度な技術がいるかなどで役割を分離してると思うのでそのまま現実の写しにはならないよという話です。

- **変更の影響範囲の拡大:** ランチタイムの時間が変わったり、会員割引の条件が変わったりした場合、ウェイターのコード（Controller 層）だけでなく、本来業務ルールを司るべきロジック（Service 層）も変更が必要になるなど、複数の場所に変更が散らばってしまいます。
- **コードの複雑化:** ウェイターのクラスが、リクエストの形式チェックと同時に、時間条件や顧客ランクといった業務ルールまで判断するようになり、クラスの責務が増えすぎて理解やテストが困難になります。
- **再利用性の低下:** 特定の業務ルールがウェイターのクラスに埋め込まれてしまうと、他のユースケースで同じルールを使いたい場合に、ウェイターのクラスを呼び出すしかなくなり、ロジックの再利用が難しくなります。

このような問題を防ぎ、システムを「変更に強く、柔軟で、保守しやすい」ものにするために、オブジェクト指向の SRP に基づいた役割分解を行います。

### システム設計における役割分解と単一責任

下記、飲食店の商品注文というユースケースをもとにしてイメージしてみる

#### 1. プレゼンテーション層（Controller の役割）：現実ではホール担当

お客様からの「リクエスト」を最初に受け付け、その「形式」をチェックする窓口です。

- **責任:** お客様からの入力（リクエスト）を正確に受け取り、システムが処理できる「形式」になっているかを確認すること。**（業務ルールには関心を持たない）**
- **現実との対比:** ホール担当がお客様から注文を聞き、「メニューにない注文をしていないか」「個数を正しく指定しているか」といった、純粋にリクエストの「形」が整っているかを確認する部分。
- **具体的な仕事:**
  - お客様からのオーダー（HTTP リクエスト）を受け付ける。
  - オーダー内容の形式（リクエストパラメータの型、必須項目の有無など）が正しいかを確認する（**形式バリデーション**）。
  - 形式が正しいオーダーを、次の工程（アプリケーション層のサービス）に引き渡す。
- **SRP の視点:** ウェイターは「お客様からの入力の受け付けと、その形式チェック」という単一の責任を持ちます。**業務ロジックや業務ルールは一切含まず、純粋に入力インターフェースとしての役割に徹します。**

#### 2. アプリケーション層（Service の役割）：現実ではホール担当＋キッチン担当

ウェイターから受け取ったオーダーに基づき、業務全体の流れを調整し、**業務ルールに基づく判断と処理**を実行します。

- **責任:** 特定の「ユースケース」（例：料理を注文する）を遂行するための、**業務ロジックの調整、実行、および業務ルールの適用**。
- **現実との対比:** ホール担当から受け取った注文伝票を元に、キッチン担当が調理の判断をし、店長が定めた料金体系や割引ルールを適用する、といった一連の「業務的な判断と処理」を連携させる部分。
- **具体的な仕事:**
  - ウェイターから受け取った形式が正しいオーダー内容に対し、現在の時間、顧客情報、在庫状況などを参照し、**業務ルール（ランチタイム制約、割引適用、提供可否など）を全て適用し、業務的に実現可能かを確認する（業務ルールチェック）**。
  - 実現可能であれば、料理作成の具体的な指示を料理人や在庫管理に渡し、料金計算なども行う。
  - 処理結果をウェイターに返す。
- **SRP の視点:** 注文処理サービスは「お客様の注文というユースケースの、業務的な遂行と調整（業務ルールの適用を含む）」という単一の責任を持ちます。リクエストの形式自体や、個々の料理の作り方、食材の物理的な管理には直接関与しません。

#### 3. ドメイン層（Model/Entity の役割）：現実ではキッチン担当

注文処理サービスからの指示に従い、実際に料理を調理します。

- **責任:** 指定されたレシピ（業務ルール）に基づき、正確に料理を調理すること。
- **現実との対比:** キッチン担当が、注文伝票を見て、レシピ通りに食材を切り、火を通し、盛り付けを行う作業。
- **具体的な仕事:**
  - 注文処理サービスからの指示（例：「カツカレーを一つ」）に従い、その料理のレシピ（業務ロジック）に基づいて調理を行う。
  - 調理プロセスを適切に管理する。
- **SRP の視点:** 料理人は「特定の料理をレシピ通りに作ること」という単一の責任を持ちます。お客様とのやり取りや、オーダーの業務的妥当性判断、食材の在庫管理には関心を持ちません。

#### 4. インフラ層（Repository の役割）：現実ではキッチン担当＋店長

食材の在庫データを管理し、注文処理サービスに情報を提供します。

- **責任:** 食材の在庫データに関する永続化（保存）と取得を担うこと。
- **現実との対比:** キッチン担当や店長が、食材の棚や冷蔵庫を見て、現在の在庫量を確認したり、発注記録を管理したりする作業。
- **具体的な仕事:**
  - 現在利用可能な食材の種類と量をデータストアから取得し、提供する。
  - 食材の消費や仕入れに伴い、在庫データを更新する。
- **SRP の視点:** 在庫リポジトリは「食材の在庫データという特定ドメインの永続化ロジック」という単一の責任を持ちます。データ形式や業務ルールには関心を持ちません。

### バリデーションと業務ルールチェックの違い

現実の飲食店でホール担当やキッチン担当がそれぞれ行っているチェックも、システムでは SRP に基づき明確に分離されます。

| 項目       | ホール担当 (Controller)                              | ホール担当＋キッチン担当 (Service)                           |
| :--------- | :--------------------------------------------------- | :----------------------------------------------------------- |
| **種類**   | **形式バリデーション**                               | **業務ルールチェック**                                       |
| **目的**   | リクエストの「形式」がシステムで処理可能かを確認する | 注文が「業務的」に有効で、実行可能かを確認する               |
| **具体例** | ・リクエストパラメータが正しい型か                   | ・その日に使える食材（在庫リポジトリ参照）を注文していないか |
|            | ・必須項目が全て入力されているか                     | ・ランチタイム外のランチメニュー注文ではないか               |
|            | ・注文数がマイナスではないか                         | ・顧客の会員ランクに応じた割引が適用されるか                 |
| **関心事** | HTTP リクエスト、データ形式、構文                    | 業務概念、ビジネスロジック、システムの整合性、リソース状況   |

ホール担当が「メニューにない料理を注文していないか」「個数が正しく指定されているか」といった基本的な確認をするのが**形式バリデーション**に対応します。これはシステムにおけるウェイター（Controller）の役割です。

一方、「ランチタイム外なのにランチメニューを注文した」といった時間制約や、「会員ランクに応じた割引」といった顧客属性に基づく判断は、現実ではホール担当が兼任することがありますが、システムにおいては**注文処理サービス（Service）が責任を持つ業務ルールチェック**として分離します。これにより、ランチタイムが変更されたり、割引条件が変わったりしても、ウェイター（Controller）のコードには影響を与えず、注文処理サービス（Service）のみを変更すればよくなり、変更に強いシステムを実現できます。

### ユースケースの粒度

「お客様が料理を注文する」「お客様が食事を終えて会計をする」といった、ユーザーがシステムと相互作用して達成する具体的な操作は、オブジェクト指向の設計におけるユースケースとして適切な粒度です。

---

> どの粒度を SRP における単一責任と言い張るかは、あるユースケースに対して、レイヤードアーキテクチャに沿って分離したものですよね。
> そしてレイヤードアーキテクチャの分離方法をなぜ採用するかといえば、利用実績があるからです。
> オブジェクト指向を現実の写しとして設計したほうが、あまり考える必要なく初期開発ができるけど、変更に弱い。
> なので後の変更に備えて、変更に強いとされる分離方法であるレイヤードアーキテクチャを採用して最初から設計する

---

### SRP とレイヤードアーキテクチャ、そして設計思想の深掘り

1.  **SRP における「単一責任」の粒度**は、多くの場合、特定のユースケース（機能要求）を、レイヤードアーキテクチャなどの**確立されたアーキテクチャパターン**に沿って概念的に分離したものです。

2.  そして、**レイヤードアーキテクチャのような分離方法を採用する大きな理由の一つは、「利用実績とそれがもたらす効果（変更容易性、保守性、テスト容易性など）」**です。

これは以下のように言い換えられます。

#### 「現実の写し」の初期の魅力と限界

- **「オブジェクト指向を現実の写し」として設計**することは、初期段階では直感的で理解しやすく、現実の業務をそのままコードに翻訳する感覚なので、**「あまり考える必要なく初期開発ができる」**ように感じられます。例えば、「営業担当オブジェクト」が「顧客リストを持つ」「契約処理をする」「売上を計上する」といった現実の営業担当がやることを全て持ってしまうイメージです。
  - **利点:** 初期段階での設計コストが低いと感じやすい。ドメイン知識の共有がしやすい場合もある。
  - **欠点:** まさにこのアプローチこそが、**「変更に弱い」**システムを生み出しがちです。なぜなら、現実の人間が複数の役割（責任）を兼任しているように、一つのオブジェクトが複数の概念的責任を持つことになりやすいからです。その結果、「営業担当の売上計上方法」が変わると、「営業担当の顧客リスト管理」のコードにも影響が出たり、そのオブジェクトのテストが複雑になったりします。

#### レイヤードアーキテクチャと SRP による「変更に強い」設計

- そのため、**「後の変更に備えて、変更に強いとされる分離方法」であるレイヤードアーキテクチャ（やクリーンアーキテクチャなど）を最初から採用して設計する**、というアプローチが推奨されます。
- このアプローチでは、現実の概念をそのまま写し取るのではなく、**「システムとして何が変更されやすく、何が変更されにくいか」**という観点から、責任を明確に分解します。
  - **Controller 層:** ユーザーインターフェース（Web、CLI など）や外部システムからの入出力形式という「変更されやすいもの」（Web フレームワークの変更など）に責任を持ちます。
  - **Service/Application 層:** 特定のユースケース（業務フロー）の調整と、業務ルールの適用という「変更されやすいもの」（業務要件の変更など）に責任を持ちます。
  - **Domain 層:** 業務の中核的な概念と、その概念固有のルールという「比較的変更されにくいもの」（ビジネスの根幹ルールなど）に責任を持ちます。
  - **Infrastructure/Repository 層:** データベースや外部 API といった「変更されやすい技術的詳細」（DB の種類変更など）に責任を持ちます。

**SRP の適用:**

- レイヤードアーキテクチャの各層は、その層が「責任を持つべき範囲」という観点で SRP を適用しています。
- さらに、各層の中にある具体的なクラスやコンポーネントも、その層の責任範囲の中で、さらに「単一の責任」を持つように設計されます。
  - 例えば、Service 層の中の「注文処理サービス」は、「注文というユースケースを完遂する」という単一の責任を持ち、その中で様々な業務ルールを適用します。

**なぜこの分離を採用するのか？**

レイヤードアーキテクチャのような分離方法を採用する最大の理由は、**「関心の分離 (Separation of Concerns)」**という設計原則にあります。これにより、

- **変更容易性:** 特定の「関心事」（例：UI の変更、業務ルールの変更、DB の変更）が変更されても、その関心事を担当する層やクラスだけを変更すればよく、他の部分への影響を最小限に抑えられます。
- **保守性:** 各クラスや層の責任が明確なので、コードを理解しやすくなります。
- **テスト容易性:** 特定のロジックが他の依存関係から分離されているため、単体テストが容易になります。
- **再利用性:** 汎用的なロジック（例：ドメインモデル）は、異なるユースケースや異なる UI からでも再利用しやすくなります。

そして、これらのメリットは、長年のソフトウェア開発の歴史の中で、様々なシステム構築の**「利用実績」**を通じて確立されてきたベストプラクティスである、ということになります。

### まとめると

オブジェクト指向は、単に現実を写すためのツールではありません。むしろ、現実の複雑な業務を、**「いかに変更に強く、柔軟なシステムとして構築するか」**という課題に対して、**「責任」という観点から概念的に分解し、抽象化するための強力な手法**です。

そして、その抽象化と分解の具体的なガイドラインとして、SRP やレイヤードアーキテクチャといった設計原則やパターンが用いられるのです。初期開発のスピードよりも、長期的なシステムの健全性を重視するアプローチと言えるでしょう。

---

> これでユースケースを決めて、アーキテクチャを決めればクラスの大枠の分離はアーキテクチャレベル（controller など）ではできそう。
> ただ、そこから SRP になるべく基づいて、さらに責務を分離していかないといけない。

---

## SRP に基づいた責務のさらなる分離：具体的な例と粒度決定の考え方

レイヤードアーキテクチャで「Controller」「Service」「Domain」「Repository」といった大枠は決まります。しかし、これらの各層の中にどんなクラスを作り、それぞれにどんな責任を持たせるかが重要です。ここでの指針となるのが SRP です。

SRP の定義は「**変更の理由が一つであるべき**」というものでしたね。これを念頭に、具体的な例で見ていきましょう。

### 例：EC サイトの「注文処理」機能

ユーザーがカートに入れた商品を注文する、というユースケースを考えます。

**1. 大枠の分離（レイヤードアーキテクチャ）**

- **Controller 層:** 注文リクエストの受け付け、応答。
- **Service 層:** 注文というユースケース全体の調整、業務ルールの適用。
- **Domain 層:** 注文、商品、顧客といったビジネスの核となる概念。
- **Repository 層:** データベースとのやり取り。

ここまでは良いとして、問題はここからです。例えば、Service 層に `OrderService` というクラスを作ったとします。

**2. SRP に違反した初期の `OrderService` の例**

```java
// SRPに違反する可能性がある例
class OrderService {
    public Order createOrder(OrderRequest request) {
        // 1. リクエストパラメータの基本的なバリデーション
        if (request.getProductId() == null || request.getQuantity() <= 0) {
            throw new IllegalArgumentException("Invalid order request.");
        }

        // 2. 在庫の確認と確保
        Product product = productRepository.findById(request.getProductId());
        if (product == null || product.getStock() < request.getQuantity()) {
            throw new BusinessException("Product out of stock or not found.");
        }
        product.decreaseStock(request.getQuantity());
        productRepository.save(product);

        // 3. 料金計算（商品の単価 * 数量、割引適用、税金計算）
        BigDecimal totalAmount = product.getPrice().multiply(new BigDecimal(request.getQuantity()));
        if (request.hasCoupon()) {
            Coupon coupon = couponRepository.findByCode(request.getCouponCode());
            totalAmount = couponService.applyDiscount(totalAmount, coupon); // クーポンサービスに依存
        }
        totalAmount = taxService.applyTax(totalAmount); // 税サービスに依存

        // 4. 注文オブジェクトの生成と保存
        Order order = new Order(request.getCustomerId(), product.getId(), request.getQuantity(), totalAmount);
        orderRepository.save(order);

        // 5. 注文確認メールの送信
        emailService.sendOrderConfirmation(order); // メールサービスに依存

        // 6. ログの記録
        logger.info("Order created successfully: " + order.getId());

        return order;
    }
}
```

この `OrderService` は、`OrderService` という抽象的な名前から想像される以上に多くのことを行っています。

### 3. SRP に基づく責務の分離と粒度決定の考え方

この `OrderService` が持つ複数の「変更の理由」を洗い出し、それぞれを独立したクラスに分離することを考えます。

**A. 「変更の理由」を洗い出す**

上記の `OrderService` の例には、少なくとも以下の変更の理由が含まれています。

1.  **リクエスト形式のバリデーションルールが変わる** (例: 数量の上限/下限、商品 ID のフォーマット)
2.  **在庫管理ロジックが変わる** (例: 在庫引き当てのタイミング、過剰注文時の挙動)
3.  **料金計算ロジックが変わる** (例: 割引の種類追加、税率変更、送料計算)
4.  **注文の永続化方法が変わる** (例: データベースのスキーマ変更、NoSQL への移行)
5.  **注文後の通知方法が変わる** (例: メールから SMS、プッシュ通知への変更、通知内容の変更)
6.  **ログの出力方法が変わる** (例: 出力フォーマット、出力先)

**B. それぞれの変更理由に対し、独立した「責任」を持つクラスを定義する**

SRP に基づき、これらの「変更の理由」ごとに責任を持つクラスを考えます。

- **リクエスト形式のバリデーション** → **`OrderRequestValidator`** (または Controller 層の責務)
  - 責任: `OrderRequest` オブジェクトの形式的な妥当性を検証すること。
  - クラス名が具体的で、何をするか明確。
- **在庫管理ロジック** → **`StockManager`** または **`InventoryService`**
  - 責任: 商品の在庫を確認し、確保/解放すること。
  - クラス名が具体的で、在庫に関する全てのロジックをここに集約。
- **料金計算ロジック** → **`PricingService`**
  - 責任: 商品価格、数量、割引、税金などに基づき最終的な料金を計算すること。
  - クラス名が具体的で、料金計算に関する変更はこのクラスに集約される。
- **注文の永続化** → **`OrderRepository`**
  - 責任: `Order` オブジェクトをデータストアに保存/取得すること。
  - これは元々分離されていますが、`OrderService` が直接 `orderRepository.save()` を呼ぶのは問題ありません。
- **注文後の通知** → **`OrderNotifier`** または **`EmailService`**
  - 責任: 注文確定後の顧客への通知（メール、SMS など）を行うこと。
  - クラス名が具体的で、通知方法の変更はこのクラスに影響する。
- **ログの記録** → これはフレームワークのロガー（例: SLF4J + Logback）を直接利用することが多いため、独立したクラスを作るよりは依存注入で解決します。

**C. SRP 適用後の `OrderService` の例**

分離されたクラスを注入（DI）して、`OrderService` は全体の流れを「調整」する役割に徹します。

```java
// SRPに準拠した例
class OrderService {
    private final OrderRequestValidator requestValidator; // 注入
    private final InventoryService inventoryService;     // 注入
    private final PricingService pricingService;         // 注入
    private final OrderRepository orderRepository;       // 注入
    private final OrderNotifier orderNotifier;           // 注入

    public OrderService(
        OrderRequestValidator requestValidator,
        InventoryService inventoryService,
        PricingService pricingService,
        OrderRepository orderRepository,
        OrderNotifier orderNotifier) {
        this.requestValidator = requestValidator;
        this.inventoryService = inventoryService;
        this.pricingService = pricingService;
        this.orderRepository = orderRepository;
        this.orderNotifier = orderNotifier;
    }

    public Order createOrder(OrderRequest request) {
        // 1. リクエストパラメータの形式バリデーション（Controller層で済ませるか、Serviceの最初で行う）
        // Controllerで基本的な形式チェック済みと仮定するか、ここで詳細なチェックを行う
        requestValidator.validate(request); // 例: 数量が0以下でないかなど、Request固有の形式チェック

        // 2. 業務ルールの適用と在庫の確認・確保
        // OrderServiceは「何を」すべきかを調整する
        Product product = inventoryService.checkAndReserveStock(request.getProductId(), request.getQuantity());

        // 3. 料金計算（これもPricingServiceの責任）
        BigDecimal totalAmount = pricingService.calculateTotalAmount(
            product.getPrice(), request.getQuantity(), request.getCouponCode());

        // 4. 注文オブジェクトの生成と保存
        Order order = new Order(request.getCustomerId(), product.getId(), request.getQuantity(), totalAmount);
        orderRepository.save(order);

        // 5. 注文確認通知
        orderNotifier.notifyOrderConfirmation(order);

        // 6. ロギング（AOPやフレームワークに任せることが多い）
        // logger.info("Order created successfully: " + order.getId());

        return order;
    }
}
```

これで `OrderService` の責務は「注文というユースケース全体を調整し、必要な処理を適切な専門家（他のサービスやリポジトリ）に依頼する」という単一の責任になりました。

#### 粒度決定のヒント：クラス名と「変更の理由」

- **クラス名が抽象的すぎないか？**
  - `Manager`, `Processor`, `Util`, `Helper`, `Service` (何のサービス？) などは、責任が不明瞭である可能性が高いサインです。
  - 良い例: `OrderService` (全体調整), `InventoryService` (在庫管理), `PricingService` (料金計算), `OrderRequestValidator` (リクエストバリデーション), `OrderNotifier` (通知)
- **そのクラスを変更する理由が複数あるか？**
  - もし「A の要件が変わったからこのクラスを変更する」「B の要件が変わったからこのクラスも変更する」というように、複数の異なる理由で同じクラスを変更する可能性がある場合、それは SRP 違反の兆候です。その場合は、A の責任と B の責任を分離することを検討します。
- **依存関係はどうか？**
  - もし一つのクラスが、全く異なる種類の多くのクラスに依存している場合、それはそのクラスが多くのことを知りすぎている（多くの責任を負っている）可能性があります。
  - 分離することで、依存関係がスリム化され、テストも容易になります。
- **ドメイン駆動設計の概念を利用する:**
  - 「在庫を管理する」という行為は、ビジネスにおいて独立した「概念」として認識されませんか？「料金を計算する」もそうではないですか？これらのビジネス上の概念が独立したクラスの責任となり得ます。

#### まとめ

SRP に基づくさらなる責務分離は、単にコードを小さくすることではありません。**「何が変更される可能性があり、その変更が他の何に影響を与えるべきではないか」**という観点から、コードの変更容易性と保守性を最大限に高めるための戦略です。

初期の段階では多少設計に時間がかかりますが、変更が多い実際のシステム開発において、この原則を徹底することは、長期的に見れば開発コストを劇的に削減し、システムの品質を向上させることに繋がります。

---

### SRP に基づいた責務のさらなる分離：ファサードとしての Service 層と各層の連携

レイヤードアーキテクチャにおいて、**Application 層の Service クラスは、特定のユースケース（例：注文処理）を遂行するためのファサード（窓口）**として機能します。これは、Controller 層からの一つのリクエストに対して、複数の下位層（Domain 層、Infrastructure 層）の様々なオブジェクトを連携・調整し、複雑な処理をシンプルに実行するための入り口となります。

このファサードパターンを意識しながら、EC サイトの「注文処理」機能の例で、SRP に基づく責務分離と各層の呼び出し関係を明確にしていきます。

#### 例：EC サイトの「注文処理」機能における各層のクラスと連携

**1. 大枠の分離（レイヤードアーキテクチャ）**

- **Presentation 層（Controller）:** 注文リクエストの受け付け、応答。
- **Application 層（Service）:** 注文というユースケース全体の調整、業務ルールの適用（ファサード）。
- **Domain 層:** 注文、商品、顧客といったビジネスの核となる概念とそのロジック。
- **Infrastructure 層（Repository など）:** データベースや外部 API とのやり取り、その他技術的な実装詳細。

---

#### 2. SRP に基づき分離された各層の具体的なクラスと責任

**A. Presentation 層 (Controller)**

- **責務:** HTTP リクエストのハンドリング、基本的な形式バリデーション、Application 層への委譲、HTTP レスポンスの生成。
- **クラス例:**
  - `OrderController`:
    - ユーザーからの HTTP リクエストを受け付け、`OrderRequest` DTO（Data Transfer Object）に変換する。
    - `OrderRequest` の**基本的な形式バリデーション**（例：必須項目があるか、数値型が正しいかなど、HTTP リクエストとしての妥当性）。これは`OrderRequestValidator`のような専用クラスに委譲するか、アノテーションベースのバリデーションライブラリを使うことが多い。
    - Application 層の `OrderService` を呼び出し、処理を委譲する。
    - `OrderService` からの戻り値を受け取り、HTTP レスポンス（JSON など）を生成して返す。
- **呼び出し元:** クライアント（ブラウザ、モバイルアプリなど）
- **呼び出し先:** `OrderService` (Application 層)

**B. Application 層 (Service) - ファサードとしての `OrderService`**

- **責務:** 特定のユースケース（注文処理）の業務フロー全体を調整し、業務ルールを適用する。下位層のオブジェクトを連携させるファサードとして機能。
- **クラス例:**
  - `OrderService` (ファサード)
    - Controller から受け取ったオーダー内容に対し、**業務ルール**（例：在庫が十分か、クーポンが有効か、注文時間制限など）を適用・確認する。
    - Domain 層のオブジェクトや、Infrastructure 層の Repository を呼び出し、必要な処理を依頼する。
    - 複数の Domain 層オブジェクトや Repository を組み合わせて、ユースケース全体を完遂する。
    - 注文完了後の通知（メールなど）もここからトリガーする。
- **呼び出し元:** `OrderController` (Presentation 層)
- **呼び出し先:**
  - `InventoryService` (Application 層の他のサービス or Domain 層と連携するサービス)
  - `PricingService` (Application 層の他のサービス or Domain 層と連携するサービス)
  - `OrderRepository` (Infrastructure 層)
  - `ProductRepository` (Infrastructure 層)
  - `CouponRepository` (Infrastructure 層)
  - `OrderNotifier` (Infrastructure 層の通知サービス)
  - `Order` (Domain 層のエンティティ、ビジネスロジック実行)

**C. Domain 層**

- **責務:** ビジネスの中核となる概念（エンティティ、値オブジェクト、集約、ドメインサービス）とそのビジネスルール（不変条件、固有の振る舞い）。
- **クラス例:**
  - `Order` (エンティティ):
    - 注文の状態管理、合計金額計算の基本ロジック（SRP の観点から料金計算そのものは`PricingService`に委譲）、注文品目の追加/削除ルールなど。
    - 例: `order.addItem(Product product, int quantity)` メソッド内で、数量がゼロ以下でないかなどの**ドメイン固有の不変条件**をチェックする。
  - `Product` (エンティティ):
    - 商品の在庫管理ロジック（在庫減算、在庫増加など）。
    - 例: `product.decreaseStock(int quantity)` メソッド内で、在庫がマイナスにならないかなどの**ドメイン固有の不変条件**をチェックする。
  - `Customer` (エンティティ):
    - 顧客の会員ランクに応じた特別処理、購入履歴など。
- **呼び出し元:** `OrderService` (Application 層)
- **呼び出し先:** 基本的には自分自身でロジックを完結。必要に応じて関連する他の Domain オブジェクトや、Repository（Infrastructure 層）を介して永続化される。

**D. Infrastructure 層 (Repository, Notifier, External APIs)**

- **責務:** データの永続化（データベースとのやり取り）、外部システム（メール送信、決済など）との連携、その他技術的な実装詳細。
- **クラス例:**
  - `OrderRepositoryImpl` (Repository):
    - `Order` オブジェクトをデータベースに保存、更新、削除、検索する。
    - DB の具体的な SQL 文や ORM（Object-Relational Mapping）フレームワーク（JPA/Hibernate など）の操作を行う。
  - `ProductRepositoryImpl` (Repository):
    - `Product` オブジェクトの永続化と取得。
  - `EmailNotificationService` (Notifier の実装):
    - 実際にメール送信 API（例: SendGrid, JavaMail API）を呼び出してメールを送信する。
  - `PaymentGatewayClient` (External APIs):
    - 決済ゲートウェイ API との連携ロジック。
- **呼び出し元:**
  - `OrderService` (Application 層)
  - `Order` や `Product` (Domain 層のエンティティから、Repository を介して呼び出すこともある)
- **呼び出し先:** データベース、外部 API、メッセージキューなど。

---

#### SRP 適用後の `OrderService` の例（各層の呼び出しを明記）

```java
// Application層: OrderService (ファサード)
class OrderService {
    // 依存オブジェクトは、他のService（Application層）、Repository（Infrastructure層）など
    private final InventoryService inventoryService;     // Application層（またはDomain層と密接連携するService）
    private final PricingService pricingService;         // Application層（またはDomain層と密接連携するService）
    private final OrderRepository orderRepository;       // Infrastructure層
    private final ProductRepository productRepository;   // Infrastructure層
    private final OrderNotifier orderNotifier;           // Infrastructure層

    public OrderService(
        InventoryService inventoryService,
        PricingService pricingService,
        OrderRepository orderRepository,
        ProductRepository productRepository,
        OrderNotifier orderNotifier) {
        this.inventoryService = inventoryService;
        this.pricingService = pricingService;
        this.orderRepository = orderRepository;
        this.productRepository = productRepository;
        this.orderNotifier = orderNotifier;
    }

    /**
     * ユースケース: ユーザーが商品を注文する
     * Controller層から呼び出される
     */
    public Order createOrder(OrderRequest request) {
        // --- ここからApplication層の責務: ユースケースの業務フロー調整と業務ルール適用 ---

        // 1. 在庫の確認と確保 (これも業務ルールの一部)
        // InventoryService (Application層) を呼び出し、Domain層のProductエンティティとRepository (Infrastructure層) を間接的に操作
        Product product = inventoryService.checkAndReserveStock(request.getProductId(), request.getQuantity());

        // 2. 料金計算 (これも業務ルールの一部)
        // PricingService (Application層) を呼び出し、Domain層のPrice計算ロジックなどを利用
        BigDecimal totalAmount = pricingService.calculateTotalAmount(
            product.getPrice(), request.getQuantity(), request.getCouponCode());

        // 3. 注文オブジェクトの生成
        // Domain層のOrderエンティティを生成
        Order order = new Order(request.getCustomerId(), product.getId(), request.getQuantity(), totalAmount);
        // 必要に応じて、Domain層のOrderエンティティ自身が持つ不変条件やロジックを実行する
        // 例: order.addOrderItem(product, request.getQuantity());

        // 4. 注文の永続化
        // OrderRepository (Infrastructure層) を呼び出し、データベースに保存
        orderRepository.save(order);

        // 5. 注文後の通知
        // OrderNotifier (Infrastructure層) を呼び出し、外部システム（メール送信）と連携
        orderNotifier.notifyOrderConfirmation(order);

        // --- Application層の責務完了 ---
        return order;
    }
}

// Presentation層: OrderController
class OrderController {
    private final OrderService orderService; // Application層への依存

    // ... コンストラクタでDI ...

    public ResponseEntity<OrderResponse> placeOrder(@RequestBody OrderRequest request) {
        // 1. リクエストパラメータの基本的な形式バリデーション (Controller層の責務)
        // 例: @Valid アノテーションや、専用のOrderRequestValidator (Presentation層) を使う
        // requestValidator.validate(request);

        // 2. Application層のServiceを呼び出し、ユースケースを実行
        Order createdOrder = orderService.createOrder(request);

        // 3. 応答用のDTOを生成し、HTTPレスポンスを返す
        OrderResponse response = new OrderResponse(createdOrder);
        return ResponseEntity.ok(response);
    }
}
```

#### SRP とファサードとしての Service 層のメリット

- **明確な責任分離:** `OrderService` は「注文処理の調整」という単一の責任を持ち、個々の具体的な処理（在庫管理、料金計算、永続化、通知）はそれぞれ専用のクラス（InventoryService, PricingService, Repository, Notifier）に委譲されています。
- **変更容易性:**
  - 在庫管理ロジックが変わっても `InventoryService` のみが変更され、`OrderService` は影響を受けません。
  - メール送信方法が変更されても `EmailNotificationService` (OrderNotifier の実装) のみが変更され、`OrderService` は影響を受けません。
- **保守性・テスト容易性:** `OrderService` は高レベルな調整ロジックに集中でき、個々の依存オブジェクトはモック化して容易にテストできます。
- **可読性:** `OrderService` の `createOrder` メソッドを見れば、注文処理の全体の流れ（ビジネスフロー）が一目で分かります。

この例は、レイヤードアーキテクチャの大枠の中で、SRP に基づいてさらに細かく責任を分離し、Application 層の Service クラスがファサードとしてどのように機能するかを具体的に示しているかと思います。

---

# 課題についての補足

Q. TodoID の存在チェックはどこに書くべきか？

A. Service 層です。ID の存在チェックは「Todo を更新する」というユースケースを構成するビジネスロジックの一部であり、HTTP 通信を専門とする Controller の責務ではありません。

Q. ResponseEntity はどこで作成すべきか？

A. Controller 層です。ResponseEntity は HTTP 通信のためのフレームワーク固有のクラスです。Service 層がこれに依存してしまうと、他の環境（CLI ツールなど）で再利用できなくなります。Service は純粋なドメインオブジェクトを返し、Controller がそれを HTTP レスポンスに変換するのが正しい役割分担です。
