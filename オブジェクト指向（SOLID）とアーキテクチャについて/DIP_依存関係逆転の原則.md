### 依存関係逆転の原則 (DIP) とは

**定義:**

1.  **上位モジュールは下位モジュールに依存してはならない。両方とも抽象に依存すべきである。**
2.  **抽象は詳細に依存してはならない。詳細は抽象に依存すべきである。**

簡単に言うと、コードにおいて具体的な実装クラス（詳細）に直接依存するのではなく、**抽象（インターフェースや抽象クラス）に依存すべき**という原則です。これにより、システム全体の柔軟性、再利用性、テスト容易性が向上します。

### データベースの例で理解する DIP

具体的なデータベースの例で考えてみましょう。

**DIP 違反の例:**

```java
// DIP違反の例
class UserRepository {
    private MySQLDatabase database; // 具体的なデータベース実装に直接依存

    public UserRepository() {
        this.database = new MySQLDatabase(); // 具体的な実装を直接インスタンス化
    }

    public User findById(String id) {
        // databaseを使ってUserを検索する処理
        return database.query("SELECT * FROM users WHERE id = ?", id);
    }
}

class MySQLDatabase {
    public User query(String sql, String... params) {
        // MySQLに接続してクエリを実行する具体的な処理
        System.out.println("MySQLからデータを取得中...");
        return new User(params[0], "Test User"); // ダミーデータ
    }
}
```

この例では、`UserRepository`が`MySQLDatabase`という具体的なクラスに直接依存しています。

- もしデータベースを PostgreSQL に変更したくなった場合、`UserRepository`のコードを修正する必要があります。
- `UserRepository`の単体テストを行う際、実際の`MySQLDatabase`が必要となり、テストが複雑になります。

**DIP 適用後の例:**

```java
// DIP適用後の例

// 1. 抽象の定義 (インターフェース)
interface Database {
    User query(String sql, String... params);
}

// 2. 具体的な実装が抽象に依存
class MySQLDatabase implements Database {
    @Override
    public User query(String sql, String... params) {
        System.out.println("MySQLからデータを取得中...");
        return new User(params[0], "Test User (MySQL)"); // ダミーデータ
    }
}

class PostgreSQLDatabase implements Database {
    @Override
    public User query(String sql, String... params) {
        System.out.println("PostgreSQLからデータを取得中...");
        return new User(params[0], "Test User (PostgreSQL)"); // ダミーデータ
    }
}

// 3. 上位モジュールが抽象に依存
class UserRepository {
    private Database database; // 抽象に依存

    // コンストラクタでDatabaseインターフェースを受け取る (DIの利用)
    public UserRepository(Database database) {
        this.database = database;
    }

    public User findById(String id) {
        return database.query("SELECT * FROM users WHERE id = ?", id);
    }
}

// 使用例
class Application {
    public static void main(String[] args) {
        // どのデータベース実装を使うかは、ここで決定・注入される
        Database mySqlDb = new MySQLDatabase();
        UserRepository userRepoWithMySQL = new UserRepository(mySqlDb);
        System.out.println(userRepoWithMySQL.findById("1"));

        Database postgreSqlDb = new PostgreSQLDatabase();
        UserRepository userRepoWithPostgreSQL = new UserRepository(postgreSqlDb);
        System.out.println(userRepoWithPostgreSQL.findById("2"));
    }
}

class User { // ダミークラス
    String id;
    String name;

    public User(String id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}
```

この DIP 適用後の例では、

- `Database`というインターフェース（抽象）を定義しました。
- `MySQLDatabase`と`PostgreSQLDatabase`は、この`Database`インターフェースを実装（つまり、抽象に依存）しています。
- `UserRepository`は、具体的なデータベース実装クラスではなく、`Database`インターフェース（抽象）に依存しています。

これにより、`UserRepository`は特定のデータベース実装の詳細を知る必要がなくなり、データベースの実装が変更されても`UserRepository`のコードは影響を受けません。また、テスト時にはモックの`Database`実装を容易に注入できるようになります。

### 関連するデザインパターン

DIP を実践するために、以下のデザインパターンが非常によく使われます。

1.  **依存性の注入 (Dependency Injection: DI)**
    DIP をコードレベルで実現するための具体的な手法です。オブジェクトが依存する別のオブジェクトを、そのオブジェクト自身が生成するのではなく、外部から渡してもらう（注入してもらう）仕組みです。
    上記の DIP 適用例では、`UserRepository`のコンストラクタで`Database`インターフェースを受け取っている部分が DI の具体例です。

    - **コンストラクタインジェクション:** コンストラクタで依存オブジェクトを受け取る
    - **セッターインジェクション:** セッターメソッドで依存オブジェクトを受け取る
    - **インターフェースインジェクション:** 特定のインターフェースを実装することで依存オブジェクトを受け取る

    DI を使うことで、オブジェクト間の結合度を下げ、変更に強く、テストしやすいコードになります。

2.  **リポジトリパターン (Repository Pattern)**
    ドメイン層（ビジネスロジック）とデータ永続化層（データベースアクセスなど）を分離するためのデザインパターンです。ドメイン層は、データの保存や取得といった詳細な操作を直接行わず、抽象化された「リポジトリ」を通じて行います。

    上記の`UserRepository`はまさにリポジトリパターンの一例です。

    - `UserRepository`は`User`オブジェクトの集合を操作する「コレクション」のように振る舞います。
    - `UserRepository`の内部で、実際にデータベースにアクセスする具体的なロジック（`Database`インターフェースを介した操作）がカプセル化されています。
    - これにより、ドメイン層はデータの保存方法（RDB、NoSQL、ファイルなど）を知る必要がなくなり、ビジネスロジックに集中できます。

### 他の SOLID 原則との関係

DIP は、他の SOLID 原則と密接に関連しており、相互に補強し合います。

- **単一責任の原則 (Single Responsibility Principle: SRP)**

  - SRP は「クラスはただ一つの責任を持つべき」と述べます。
  - DIP を適用することで、上位モジュールが下位モジュールの具体的な実装の詳細を知る責任から解放されます。例えば、`UserRepository`は「ユーザーデータを管理する」という責任に集中でき、データベース接続の具体的な詳細については関知しなくなります。これにより、`UserRepository`の SRP が守られます。

- **オープン・クローズドの原則 (Open/Closed Principle: OCP)**

  - OCP は「ソフトウェアエンティティ（クラス、モジュール、関数など）は拡張に対して開かれ、修正に対して閉じているべき」と述べます。
  - DIP を適用することで、新しいデータベース実装を追加する場合でも、既存の`UserRepository`（上位モジュール）を修正する必要がなくなります。新しいデータベース実装は`Database`インターフェースを実装するだけでよく、システムが拡張に対して開かれ、既存のコードは修正に対して閉じている状態になります。

- **リスコフの置換原則 (Liskov Substitution Principle: LSP)**

  - LSP は「派生型はその基底型と置換可能でなければならない」と述べます。
  - DIP は抽象に依存するため、その抽象を実装するどのような具体的なクラスでも、元のクラスと置換可能である必要があります。例えば、`UserRepository`が`Database`インターフェースに依存している限り、`MySQLDatabase`でも`PostgreSQLDatabase`でも、同じように機能することが LSP によって保証されます。

- **インターフェース分離の原則 (Interface Segregation Principle: ISP)**
  - ISP は「クライアントは、使用しないメソッドに依存すべきではない」と述べます。
  - DIP で定義する抽象（インターフェース）が大きすぎると、その抽象に依存するクライアントが不要なメソッドまで依存してしまう可能性があります。ISP は、DIP で作成するインターフェースを適切に小さく、目的に特化したものに保つことを促し、より効果的な依存関係の逆転を支援します。

---

### まとめ

依存関係逆転の原則 (DIP) は、システムの柔軟性、再利用性、テスト容易性を高めるための非常に重要な原則です。抽象に依存することで、具体的な実装からの分離を図り、変更に強いアーキテクチャを構築できます。DI やリポジトリパターンといったデザインパターンは、DIP を実践するための強力なツールであり、他の SOLID 原則と組み合わせることで、より堅牢で保守性の高いソフトウェア開発が可能になります。

---

## Q.DIP は抽象に依存すべきということでしたよね？OCP も変更に強くなるために結果抽象に依存すべきという感じでしたよね？何が違うんでしょう

はい、DIP も OCP も「抽象に依存する」という点で共通しており、結果的に「変更に強くなる」という効果をもたらします。そのため、概念的に近いと感じるのは当然のことです。

しかし、両者は**目的と視点**が異なります。

### 依存関係逆転の原則 (DIP) の目的と視点

- **目的:** モジュール間の具体的な依存関係をなくし、**上位モジュールが下位モジュールに依存するのを防ぐ**こと。代わりに、**両方が抽象に依存する**ようにすること。
- **視点:** **依存関係の方向**に注目します。特に、**「上位モジュールが下位モジュールの詳細に直接結合することを避ける」**という点に焦点を当てています。
- **「抽象が詳細に依存してはならない。詳細は抽象に依存すべきである。」**という DIP の後半の定義は、インターフェースを定義する際に、そのインターフェースが特定の具体的な実装の都合に引きずられないように（抽象は抽象として汎用的に定義されるべきである）という意図も含まれます。

**DIP の例を再確認:**
`UserRepository`（上位モジュール）が`MySQLDatabase`（下位モジュールの詳細）に直接依存するのではなく、`Database`インターフェース（抽象）に依存するようにします。これにより、`UserRepository`は具体的なデータベースの実装が何であるかを知らなくても機能できるようになります。

### オープン・クローズドの原則 (OCP) の目的と視点

- **目的:** 既存のコードを**修正することなく**、新しい機能を追加できるようにすること。つまり、**拡張に対しては開かれており、修正に対しては閉じている**状態にすること。
- **視点:** **変更の発生源と影響範囲**に注目します。特に、**「システムの動作を変更・拡張する際に、既存のソースコードを触らずに済むか」**という点に焦点を当てています。この「変更」には、具体的な実装の変更や新しい実装の追加などが含まれます。

**OCP の例を再確認:**
新しいデータベース（例: `PostgreSQLDatabase`）を追加したい場合、`UserRepository`のコードを修正せずに、`PostgreSQLDatabase`クラスと`Database`インターフェースの実装を追加するだけで対応できるようにします。これは、`UserRepository`が`Database`インターフェースに依存しているおかげです。

### 違いのまとめ

| 特徴         | 依存関係逆転の原則 (DIP)                                                                     | オープン・クローズドの原則 (OCP)                                                             |
| :----------- | :------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------- |
| **主な目的** | 具体的なモジュール間の直接的な依存関係を逆転させ、**抽象への依存**を促す。                   | 既存のコードを**修正せずに機能拡張**を可能にする。                                           |
| **視点**     | **依存関係の方向と性質**。特に上位モジュールから下位モジュールへの結合の排除。               | **変更への影響**。特に既存コードの修正回避。                                                 |
| **実現手段** | 抽象（インターフェース、抽象クラス）を導入し、上位・下位モジュールがそれに依存する。         | 抽象化、ポリモーフィズム、継承、ストラテジーパターンなどを用いて、変更の影響範囲を限定する。 |
| **関係性**   | OCP を達成するための**具体的な手段**の一つ。DIP を適用することで、OCP が達成されやすくなる。 | 拡張性と保守性を高めるための**高レベルな設計原則**。DIP はその実現に貢献する。               |

### 非常に重要な関係性

DIP は、OCP を達成するための**具体的な手法**や**基盤**を提供すると考えることができます。

- OCP は「修正せずに拡張できるようにしよう」という**目標**を掲げます。
- DIP は「そのためには、上位モジュールは具体的な下位モジュールではなく、抽象に依存するようにしよう」という**具体的な指針**を与えます。

つまり、DIP を適用して抽象に依存することで、結果として OCP が満たされる（新しい具体的な実装を追加しても、既存のコードを修正する必要がない）という関係になります。

OCP は DIP だけでなく、他にも様々なデザインパターンや原則（ストラテジーパターン、テンプレートメソッドパターンなど）を使って達成され得ます。しかし、モジュール間の依存関係を考慮する上で、DIP は OCP の非常に強力な実現手段となります。

### イメージで例えるなら

- **OCP:** 「この建物の部屋は、**内装を変えずに**家具や家電を自由に入れ替えられるように作ろう！」という目標。
- **DIP:** 「そのためには、家具や家電を直接壁に固定するのではなく、**標準的なコンセントや配管、間仕切りという抽象的な仕組み**に接続できるように作ろう！」という具体的な設計原則。

この「標準的なコンセントや配管、間仕切り」が「抽象（インターフェース）」に当たります。DIP を守って設計することで、OCP が達成されるわけです。

---

## Q. また上位と下位は相対的なものと聞きましたが、具体的にどうなるでしょう？

> 私見まとめ
> 上位のモジュール ⇒ アプリケーションのより**目的**に近いほう（what、なにをするか）
> 下位のモジュール ⇒ 目的達成のための**手段**に近いほう（how、どのように実現するか）
> 宣言的と手続き的の話に似てますかね。

はい、まさにその通りで、**上位モジュールと下位モジュールは相対的な概念**です。これは DIP を理解する上で非常に重要なポイントです。

特定のモジュールが常に「上位」であるとか、常に「下位」であると固定されているわけではありません。あるモジュールが、ある文脈では上位モジュールとして振る舞い、別の文脈では下位モジュールとして他の上位モジュールに利用される、ということが頻繁に起こります。

### 相対性の具体例

先ほどのユーザー管理の例を拡張して考えてみましょう。

**登場するモジュール（仮）:**

1.  **`ApplicationController`**: HTTP リクエストを受け付け、どのサービスを呼び出すかを決定する。
2.  **`UserService`**: ユーザーの登録、ログイン、情報更新などのビジネスロジックを管理する。
3.  **`UserRepository`**: ユーザーデータを永続化層から取得・保存する。
4.  **`Database`インターフェース**: データベース操作の抽象。
5.  **`MySQLDatabase`**: `Database`インターフェースの実装。
6.  **`Logger`インターフェース**: ログ出力の抽象。
7.  **`ConsoleLogger`**: `Logger`インターフェースの実装（コンソールに出力）。
8.  **`FileLogger`**: `Logger`インターフェースの実装（ファイルに出力）。

**依存関係の階層（相対性）:**

- **最上位の文脈:**

  - `ApplicationController`は、`UserService`を利用します。この文脈では、`ApplicationController`が**上位モジュール**、`UserService`が**下位モジュール**となります。
  - しかし、`ApplicationController`は`UserService`の具体的な実装（例: `UserServiceImpl`）ではなく、`UserService`インターフェースに依存すべきです（これも DIP）。

  ```
  ApplicationController --uses--> UserService (Interface)
  ```

- **中間層の文脈:**

  - `UserService`は、ユーザーデータを操作するために`UserRepository`を利用します。
  - この文脈では、`UserService`が**上位モジュール**、`UserRepository`が**下位モジュール**となります。
  - ここでも、`UserService`は`UserRepository`の具体的な実装ではなく、`UserRepository`インターフェースに依存すべきです。

  ```
  UserService --uses--> UserRepository (Interface)
  ```

- **永続化層の文脈:**

  - `UserRepository`は、実際にデータを永続化するために`Database`インターフェースを利用します。
  - この文脈では、`UserRepository`が**上位モジュール**、`Database`インターフェースが**下位モジュール**となります。
  - `UserRepository`は、`MySQLDatabase`や`PostgreSQLDatabase`といった具体的な実装ではなく、`Database`インターフェースに依存します。

  ```
  UserRepository --uses--> Database (Interface)
  ```

- **ロギングの文脈:**

  - 例えば、`UserService`や`UserRepository`、あるいは`ApplicationController`といった多くのモジュールは、エラーやイベントを記録するためにロギング機能を利用するでしょう。
  - この場合、ロギング機能を利用する側のモジュール（例: `UserService`）が**上位モジュール**、`Logger`インターフェースが**下位モジュール**となります。
  - そして、`ConsoleLogger`や`FileLogger`は、`Logger`インターフェースを実装する、最も具体的な**下位モジュール**となります。

  ```
  UserService --uses--> Logger (Interface)
  ```

### まとめると

上記の例では、

- `UserService`は`ApplicationController`から見れば「下位」ですが、`UserRepository`から見れば「上位」です。
- `UserRepository`は`UserService`から見れば「下位」ですが、`MySQLDatabase`から見れば「上位」です。

このように、モジュールは他のモジュールにサービスを提供する（そのモジュールから見れば「下位」）と同時に、他のモジュールを利用して自身の機能を実現する（その利用されるモジュールから見れば「上位」）という、**多層的な役割**を担います。

DIP の目的は、このモジュール間の依存関係において、**上位のビジネスロジックを扱うモジュールが、下位の技術的詳細を扱うモジュールの具体的な実装に直接依存するのを避ける**ことです。

つまり、どのモジュールが「上位」で「下位」であるかは、そのモジュールが**どのような粒度で、どのような目的の機能を提供しているか**、そして**他のどのモジュールとどのような関係にあるか**によって決まります。常に抽象に依存するという原則を守ることで、この相対的な関係性の変更にも柔軟に対応できるシステムを構築できます。
