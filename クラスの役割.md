# **レイヤードアーキテクチャ**

1.  **プレゼンテーション層 (Controller)**
2.  **ビジネスロジック層 (Service)**
3.  **データアクセス層 (Mapper)**

それでは、この 3 つの主要なクラス(`Controller`, `Service`, `Mapper`)に焦点を当てて、SRP に基づいた責務と役割を再定義します。

---

## `Controller`, `Service`, `Mapper` による SRP に基づいたクラス責務

### 1. Controller 層 (プレゼンテーション層)

**クラス例:** `UserController`, `ProductController`

**責務:**

- **HTTP リクエストの受付と応答:** クライアントからの HTTP リクエスト（GET, POST, PUT, DELETE など）を受け取り、適切な HTTP レスポンスを返します。
- **リクエストデータのバインディングと基本的なバリデーション:** リクエストボディやパスパラメータ、クエリパラメータを Java オブジェクトにバインドし、そのオブジェクトに定義されたアノテーションベースの基本的な形式チェック（例: `@NotNull`, `@Size`）を行います。
  - **補足:** 明示的な`Form`クラスがない場合、リクエストデータを直接`Entity`オブジェクト（ただし、通常は永続化用とリクエスト用の`Entity`は分けるべき）で受け取るか、シンプルな POJO (`Data Transfer Object`的な役割を持つクラス) で受け取ることが多いです。
- **Service 層への処理の委譲:** バリデーションが成功した後、ビジネスロジックの実行を Service 層に委譲します。
- **Service 層からの結果の変換と返却:** Service 層からの処理結果（例: `Entity`オブジェクト、`List<Entity>`など）を受け取り、必要に応じてクライアントに返すための形式に変換して HTTP レスポンスとして返却します。
  - **補足:** 明示的な`Response`クラスがない場合、`Entity`を直接返すこともありますが、セキュリティや API 契約の観点からは DTO（ここでは`Response`がその役割を担う）を介することが推奨されます。
- **例外のハンドリング (プレゼンテーション層に特化したもの):** HTTP ステータスコードへの変換など、プレゼンテーション層の視点でのエラーハンドリングを行います。

**役割:**

- 外部からの API リクエストを受け付ける唯一の入り口（エンドポイント）として機能します。
- HTTP プロトコルに特化した処理、およびクライアントとの I/O データの形式変換（JSON/XML など）のみを担当します。

### 2. Service 層 (ビジネスロジック層)

**クラス例:** `UserService`, `ProductService`

**責務:**

- **ビジネスロジックの実行:** アプリケーションのコアとなるビジネスルールやプロセスを実行します。これには、複数の`Mapper`操作を調整することや、ドメイン固有の複雑な計算などが含まれます。
- **データの一貫性の維持 (トランザクション管理):** 関連するデータ操作全体でトランザクションを管理し、データの一貫性を保証します。
- **ビジネスバリデーション:** データがビジネスルールに準拠しているかを確認します（例: ユーザー名がユニークか、注文時に在庫があるか）。
- **Mapper へのデータ操作の委譲:** データの永続化、更新、削除、およびデータの取得（検索）といった具体的なデータベース操作を`Mapper`に委譲します。
  - **補足:** `Entity`が明確に定義されていれば、`Entity`を`Mapper`に渡して永続化し、`Mapper`から`Entity`を受け取る形になります。
- **ビジネス処理結果の Controller 層への返却:** ビジネスロジックの実行結果を Controller 層に返します。この際、生の`Entity`を返すこともあれば、特定のビジネス要件に応じたオブジェクトを返すこともあります。

**役割:**

- アプリケーションのビジネス上の「何を、どのように行うか」を定義し、実行する中心的な場所です。
- データアクセス層とプレゼンテーション層の間で、ビジネスロジックをカプセル化し、分離します。

### 3. Mapper 層 (データアクセス層)

**クラス例:** `UserMapper`, `ProductMapper`

**責務:**

- **データ永続化の抽象化:** データベースの種類やアクセス方法の詳細を Service 層から隠蔽します。
- **OR マッパーとしての役割:**
  - **データベース操作の定義:** OR マッパー（MyBatis）を使用して、データベースに対する CRUD（Create, Read, Update, Delete）操作を定義します。
  - **オブジェクト-リレーショナルマッピング:** データベースのテーブルと Java のオブジェクト（`Entity`など）間のマッピングを行います。データベースからの結果セットを Java オブジェクトに変換し、Java オブジェクトの状態変更をデータベースに反映します。
- **データ取得の提供:** Service 層からの要求に基づいて、特定の条件に合致するデータをデータベースから取得し、Java オブジェクト（`Entity`や`Map`など）として返却します。

**役割:**

- データベースとの唯一の接点であり、データアクセスロジックをカプセル化します。
- Service 層に対して、抽象化されたデータ操作インターフェースを提供し、データベースの詳細な実装から Service 層を切り離します。

---

### この構成における「レイヤードアーキテクチャ」の性質

この `Controller` -> `Service` -> `Mapper` の流れは、伝統的な三層（または四層）のレイヤードアーキテクチャの典型的なパターンです。

- **プレゼンテーション層 (Controller):** ユーザーインターフェースや API エンドポイント
- **ビジネスロジック層 (Service):** アプリケーションのビジネスルールとフロー
- **データアクセス層 (Mapper):** データの永続化と取得

各層が単一の責任を持ち、上位層が下位層に依存し、下位層は上位層に依存しないという原則（依存性逆転の原則は適用されないが、依存性の方向は一方向）が守られています。

はい、**レイヤードアーキテクチャと MVC モデルは、概念的に異なるものであり、別物と考えるべきです。** ただし、両者はしばしば組み合わせて使われます。

### レイヤードアーキテクチャとは

レイヤードアーキテクチャは、**ソフトウェアの機能を論理的に分割し、階層化する**設計パターンです。各層は特定の責任を持ち、通常は上位層が下位層の機能を利用しますが、下位層は上位層の存在を知りません。

一般的な層の例としては、以下のようなものがあります。

- **プレゼンテーション層 (Presentation Layer):** ユーザーインターフェースや外部からのリクエストを受け付け、応答を返す。
- **アプリケーション層 (Application Layer):** プレゼンテーション層からの要求を受け、ビジネスロジックを調整・実行する。
- **ドメイン層 (Domain Layer) / ビジネスロジック層 (Business Logic Layer):** アプリケーションのコアとなるビジネスルールやドメインの知識をカプセル化する。
- **インフラストラクチャ層 (Infrastructure Layer) / データアクセス層 (Data Access Layer):** 永続化、外部システム連携、ユーティリティ機能など、技術的な詳細を扱う。

あなたの`Controller`, `Service`, `Mapper`の構成は、まさにこのレイヤードアーキテクチャ（特に三層アーキテクチャ）の典型例です。

### MVC モデルとは

MVC（Model-View-Controller）モデルは、**ユーザーインターフェースを持つアプリケーションを設計するためのパターン**です。これは、ユーザーインターフェースの関心を 3 つの要素に分離することで、開発、テスト、保守を容易にすることを目的としています。

- **Model:** アプリケーションのデータとビジネスロジックをカプセル化します。ビューに表示されるデータの状態を管理し、変更があればビューに通知します。
- **View:** ユーザーにデータを表示する役割を持ちます。モデルの変更に応じて表示を更新しますが、モデルのデータ自体を変更するロジックは持ちません。
- **Controller:** ユーザーからの入力（イベント）を受け取り、それをモデルやビューへのコマンドに変換します。例えば、ボタンのクリックやテキスト入力などを処理し、モデルの更新を指示したり、ビューの切り替えを指示したりします。

### レイヤードアーキテクチャと MVC モデルの関係

- **異なる目的:**
  - **レイヤードアーキテクチャ:** アプリケーション全体の**論理的な構造**を定義し、関心事を分離することで、スケーラビリティ、保守性、テスト容易性を向上させます。
  - **MVC モデル:** 特に**ユーザーインターフェースを持つ部分の設計**に焦点を当て、UI 関連の関心事を分離することで、UI 開発の複雑さを軽減します。
- **相互に排他的ではない:** 両者は相互に排他的ではなく、むしろ**組み合わせて使われることが多い**です。
  - 例えば、Spring Framework を使った Web アプリケーションでは、`Controller`が MVC の Controller の役割を果たし、`Service`と`Mapper`（および`Entity`）が Model の役割の一部（ビジネスロジックとデータ管理）を担うことが多いです。`View`は通常、HTML テンプレートなどによって実現されます。
  - レイヤードアーキテクチャのプレゼンテーション層の一部として、MVC モデルが適用されると考えることができます。

まとめると、レイヤードアーキテクチャはアプリケーション全体の構造を定義する「大局的な設計」であり、MVC モデルは特に UI 部分の責務を分ける「局所的な設計」であると言えます。

---

#### 1. 疎結合の促進

- **Entity の変更の影響範囲の抑制:**

  - `Entity`はデータベースのテーブル構造と密接に関連しており、永続化の都合やビジネスロジックの変更によってフィールドが追加・削除されたり、型が変わったりすることがあります。
  - もし`Controller`が直接`Entity`を受け取ったり返したりしていると、`Entity`が変更されるたびに`Controller`も変更する必要が出てきます。これは結合度が高い状態です。
  - `DTO`（Data Transfer Object）を挟むことで、`Entity`の変更が`Controller`に直接影響するのを防げます。`DTO`は API の契約として固定され、内部の`Entity`の構造変更は`Service`層や`Mapper`で`DTO`への変換ロジックを調整するだけで済み、`Controller`（およびクライアント）への影響を最小限に抑えられます。
  - **例:** `UserEntity`に`password_hash`というカラムを追加しても、`UserResponseDTO`には`password_hash`を含めない限り、API のレスポンスは変わりません。

- **責務の分離:**
  - `Entity`は、永続化（データベースへのマッピング）とビジネスロジック（ドメインモデル）の責務を主に持ちます。
  - `DTO`は、データ転送（API の入出力フォーマット）の責務を持ちます。
  - これらの責務を分離することで、各クラスが単一責任の原則（SRP）をより厳密に守れます。`Entity`に不要なバリデーションアノテーション（例: `@Min` や `@Max` for API input）が付与されるのを防ぎ、`Controller`が永続化に関するアノテーション（例: `@Table`, `@Column`）に依存するのを防げます。

#### 2. セキュリティと API 契約の明確化

- **機密情報の漏洩防止:**

  - `Entity`には、`passwordHash`、`APIKey`、`private_address`など、データベースに保存されるべきだが、API を通じてクライアントに公開すべきでない機密情報が含まれることがあります。
  - `Entity`を直接返してしまうと、これらの機密情報が意図せずクライアントに漏洩するリスクがあります。
  - `DTO`を使用すれば、API の契約として公開するフィールドだけを厳選して定義できるため、セキュリティリスクを大幅に軽減できます。

- **API の契約とバージョニングの容易さ:**

  - `DTO`は、その API が提供するデータ形式の明確な契約となります。クライエンスは`DTO`の構造を見て、どのようなデータがやり取りされるかを理解できます。
  - API のバージョンアップで内部の`Entity`構造は変わっても、`DTO`の構造を維持すれば、既存クライアントへの影響を最小限に抑えられます。
  - `Entity`は DB の物理構造に近いため、DB 変更に影響を受けやすいですが、`DTO`は外部との論理的な契約であるため、柔軟に変更できます。

- **データの集約と整形:**
  - API レスポンスとして、複数の`Entity`のデータを組み合わせて返したい場合や、特定の形式にデータを整形して返したい場合があります。
  - `DTO`は、このような集約や整形をカプセル化するのに最適な場所です。例えば、`UserEntity`と`AddressEntity`を結合して`UserDetailResponseDTO`を生成できます。

### 具体的なシナリオ

**悪い例 (Entity を直接やり取り)**

```java
// UserEntity (DBと密結合)
@Entity
public class User {
    @Id private Long id;
    private String username;
    private String passwordHash; // 機密情報
    private String email;
    private LocalDateTime createdAt;
    // ... 他のフィールドやビジネスロジック
}

// UserController
@RestController
public class UserController {
    @Autowired private UserService userService;

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) { // Entityを直接返す
        return userService.getUserById(id);
    }

    @PostMapping("/users")
    public User createUser(@RequestBody User user) { // Entityを直接受け取る
        // ここでUserエンティティのすべてのフィールドを受け取ってしまう
        return userService.createUser(user);
    }
}
```

この例では、`passwordHash`のような機密情報が API レスポンスに含まれる可能性があり、`createUser`でクライアントが勝手に`createdAt`のような値を設定できてしまうリスクがあります。また、`UserEntity`のフィールドが追加・変更されるたびに、API のレスポンス構造も自動的に変わり、クライアント側の修正が必要になる可能性があります。

**良い例 (DTO を挟む)**

```java
// UserEntity (DBと密結合、ビジネスロジックを持つ)
@Entity
public class User {
    @Id private Long id;
    private String username;
    private String passwordHash; // 機密情報
    private String email;
    private LocalDateTime createdAt;
    // ... 他のフィールドやビジネスロジック
}

// UserCreateRequest (Formの役割)
public class UserCreateRequest {
    @NotBlank private String username;
    @NotBlank @Size(min = 8) private String password;
    @Email private String email;
}

// UserResponse (Responseの役割)
public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private LocalDateTime createdAt;
    // passwordHashは含まない
}

// UserMapper (例: MapStruct)
@Mapper(componentModel = "spring")
public interface UserApiMapper {
    User toEntity(UserCreateRequest request); // RequestDTO -> Entity
    UserResponse toResponse(User user);      // Entity -> ResponseDTO
}

// UserService
@Service
public class UserService {
    @Autowired private UserRepository userRepository; // JPA Repositoryなど
    @Autowired private UserApiMapper userApiMapper;

    public UserResponse createUser(UserCreateRequest request) {
        // ビジネスバリデーション
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new IllegalArgumentException("Username already exists.");
        }
        User user = userApiMapper.toEntity(request); // DTOからEntityへ変換
        user.setCreatedAt(LocalDateTime.now()); // Serviceで設定
        user.setPasswordHash(hashPassword(request.getPassword())); // パスワードハッシュ化
        User savedUser = userRepository.save(user);
        return userApiMapper.toResponse(savedUser); // EntityからResponseDTOへ変換
    }

    public UserResponse getUserById(Long id) {
        User user = userRepository.findById(id)
                                .orElseThrow(() -> new NotFoundException("User not found"));
        return userApiMapper.toResponse(user);
    }
}

// UserController
@RestController
public class UserController {
    @Autowired private UserService userService;

    @GetMapping("/users/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }

    @PostMapping("/users")
    @ResponseStatus(HttpStatus.CREATED)
    public UserResponse createUser(@Valid @RequestBody UserCreateRequest request) { // RequestDTOを受け取る
        return userService.createUser(request);
    }
}
```

この「良い例」では、各層が自分の責任範囲のデータ形式のみを扱い、外部の関心事から独立しているため、疎結合で安全なシステムが構築できます。
